# Дипломная работа.

````bash
$ terraform version
Terraform v1.3.6
on linux_amd64
````

#### 1. Папка "Folder":

1.1. Удалить файлы состояний Терраформа.

1.2. Инициализировать конфигурацию Терраформ:
````bash
$ terraform init
````

1.3. Создать рабочие пространства:
````bash
$ cd /run/media/oleg/Second/Netology/devops-diploma-yandexcloud/16-diploma-yc/terraform/stage_000
$ terraform workspace new stage
$ terraform workspace new prod
$ terraform workspace list    
  default
* prod
  stage

$ terraform workspace select stage
Switched to workspace "stage".

$ terraform workspace show
stage
````

1.4. Применить конфигурацию:
````bash
$ terraform apply -auto-approve
...
Apply complete! Resources: 8 added, 0 changed, 0 destroyed.

Outputs:

current-workspace-name = "stage"
remote_execution_determine = "Run environment: Local"
yc-folder-id = "b1gev5pjkllbpo53oqgh"
yc-id = "b1g8mq58h421raomnd64"
yc-zone = "ru-central1"
````

1.5. Указать идентификатор каталога в объявлении переменных окружения в файле `~/.zshrc`.
````bash
export YC_FOLDER_ID=<Идентификатор Каталога>
````

1.5. Инициализировать командную строку:
````bash
$ yc init
````

1.6. Получить список существующих сервисных аккаунтов:
````bash
$ yc iam service-account list
+----------------------+--------------+
|          ID          |     NAME     |
+----------------------+--------------+
| ajerdgngm87b52pc9m9o | terraform-sa |
+----------------------+--------------+
````

1.7. Создать ключ доступа для существующего сервисного аккаунта:
````bash
$ yc iam access-key create --service-account-name terraform-sa
access_key:
  id: ajeei21ts3bojbmismcg
  service_account_id: ajenr59jpld42kifad9r
  created_at: "2023-01-16T05:50:21.783352133Z"
  key_id: YCAJEVGNlIHVaq2VGHH6HKkiJ
secret: YCMq-CHlKppLrNQkRXNrdR7etbiDJ3qNQenIQXka
````

> Значение секретного ключа (поле `secret`) повторно получить невозможно, поэтому его следует сразу сохранить
> в безопасном месте!

> Список существующих ключей доступа для сервисного аккаунта `terraform-sa`:
> ````bash
> $ yc iam access-key list --service-account-name terraform-sa
> +----------------------+----------------------+---------------------------+
> |          ID          |  SERVICE ACCOUNT ID  |          KEY ID           |
> +----------------------+----------------------+---------------------------+
> | ajeb24tdu91nr03ova01 | ajerdgngm87b52pc9m9o | YCAJEu43b6gYLWk8ImqC57bQw |
> | ajeb4lijdl50n1er7th7 | ajerdgngm87b52pc9m9o | YCAJE4DJCKusGfLnjY2nNuLVP |
> +----------------------+----------------------+---------------------------+
> ````

1.8. Указать ключи доступа в объявлении переменных окружения в файле `~/.zshrc`.
````bash
export AWS_ACCESS_KEY_ID=<Значение key_id>
export AWS_SECRET_ACCESS_KEY=<Значение secret>
````

1.9. Реинициализировать консоль для вступления в силу новых значений переменных:
````bash
$ source ~/.zshrc
````

#### 2. Папка "Backend":

2.1. Инициализировать конфигурацию Терраформ:
````bash
$ terraform init
````

2.2. Создать рабочие пространства:
````bash
$ terraform workspace new prod
...
$ terraform workspace new stage
...
$ terraform workspace list
  default
  prod
* stage
````

2.3. Применить конфигурацию:
````bash
$ terraform apply -auto-approve
````

Если использовалось рабочее пространство `default`, то непосредственно в корне бакета появиться файл `tfstate`:
![tfstate.png](images%2Ftfstate.png)

Если инициализация бэкенда производилась в рабочем пространстве, отличном от `default`, то в бакете
появиться папка с именем, заданным в параметре `workspace_key_prefix` бэкенда (если параметр не задавался,
то его значение по умолчанию -  `env:`). В этой папке будет лежать другая папка с именем текущего
рабочего пространства, а уже в ней - файл с именем, заданным в параметре `key` бэкенда.

|                                            |                                                        |                                                                        |
|:------------------------------------------:|:------------------------------------------------------:|:----------------------------------------------------------------------:|
| ![tfstate_ws.png](images%2Ftfstate_ws.png) | ![tfstate_ws_stage.png](images%2Ftfstate_ws_stage.png) | ![tfstate_ws_stage_tfstate.png](images%2Ftfstate_ws_stage_tfstate.png) |


> Формат пути к файлу `terraform.tfstate`: `workspace_key_prefix/workspace_name/key`
> 
> Дефолтное значение параметра `workspace_key_prefix` - "env:".

#### 3. Папка "Common Configuration":

3.1. Инициализировать конфигурацию Терраформ:
````bash
$ terraform init
````

3.2. Создать рабочие пространства:
````bash
$ terraform workspace new prod
...
$ terraform workspace new stage
...
$ terraform workspace list
  default
  prod
* stage
````

3.3. Применить конфигурацию:
````bash
$ terraform apply -auto-approve
````

#### 4. Папка "Configuration 1":

3.1. Инициализировать конфигурацию Терраформ:
````bash
$ terraform init
````

3.2. Создать рабочие пространства:
````bash
$ terraform workspace new prod
...
$ terraform workspace new stage
...
$ terraform workspace list
  default
  prod
* stage
````

3.3. Применить конфигурацию:
````bash
$ terraform apply -auto-approve
````





13. Перейти в другую папку конфигурации Терраформ:
````bash
$ cd /run/media/oleg/Second/Netology/devops-diploma-yandexcloud/16-diploma-yc/terraform/stage_100
$ source ~/.zshrc
````

14. Создать рабочие пространства:
````bash
$ terraform workspace new prod
$ terraform workspace new stage
$ terraform workspace list    
  default
  prod
* stage
````

15. Инициализировать Терраформ:
````bash
$ terraform init
````

16. Применить конфигурацию Терраформ:
````bash
$ terraform apply -auto-approve
````



---

Терраформ использует сохраняемые состояния для отслеживания и управления ресурсам.
Здесь существует два варианта - интеграция с Terraform Cloud или использовать бэкенд, который определяет,
где именно Терраформу сохранять свои данные.
Такой подход позволяет нескольким пользователям иметь доступ к сохраняемым состояниям
и совместно работать с ресурсами.

Терраформ сохраняет конфигурацию в виде простого текста в двух файлах:
- `.terraform/terraform.tfstate` - содержит конфигурацию бэкенда для текущей рабочей директории;
- файлы планов, которые используют информацию из файла `.terraform/terraform.tfstate` во время создания плана чтобы
  гарантировать применение плана к правильному набору инфраструктуры;

При применении предварительного сохранённого плана Терраформ использует конфигурацию бэкенда, сохраненную в этом файле
вместо текущих настроект бэкенда.

Когда изменяется конфигурация бэкенда, то нужно снова выполнить `terraform init` для валидации и конфигурировании
бекенда до выполнения операций `plan`, `apply` или `state`.

После выполнения `terraform init` Терраформ локально создаст директорию `.terraform/`. Эта директория содержит последние
бэкенд конфигурации, включая все аутентификационные параметры, предоставленные посредством Terraform CLI.
Не следует сохранять директорию `.terraform/` в Git-репозитории, поскольку это может повлечь утечку чувствительных
данных.

Локальная конфигурация бэкенда отличается и полностью отделена от файла `terraform.tfstate`, хранящего данные состояния
о реальной инфраструктуре. Терраформ сохраняет файл `terraform.tfstate` в удалённом бэкенде.

При изменении бэкендов Терраформ предоставляет возможность мигрировать состояние в новый бэкенд. Это позволяет
переносить бэкенды без потери существующего состояния.

> ВАЖНО: Перед миграцией в новый бэкенд настоятельно рекомендуется вручную сохранить состояние путем копирования
> файла `terraform.tfstate`

---

#### Локальные бэкенды

Локальные бэкенды сохраняют состояние в локальной файловой системе, защищают эти состояния, используя системные API
и выполняют операции локально.

````bash
terraform {
  backend "local" {
    path = "relative/path/to/terraform.tfstate"
  }
}
````

````bash
data "terraform_remote_state" "foo" {
  backend = "local"

  config = {
    path = "${path.module}/../../terraform.tfstate"
  }
}
````

#### Для чего нужно удалённое состояние

По-умолчанию Терраформ сохраняет своё состояние локально в файле с именем `terraform.state`. При командной
работе с Терраформом использование локального файла затрудняет использование Терраформа потому что
каждый участник всегда должен использовать последнее состояние и быть уверенным, что никто больше не запускает
Терраформ в этот же момент.
При использовании же удаленного состояния Терраформ записывает данные состояния в удалённое хранилище, доступ
к которому м.б. разделён между членами команды.


#### Удалённые бэкенды

Удалённый бэкенд является уникальным среди всех остальных бэкендов Терраформа, потому что может и сохранять снимки
состояний и выполнять операции в Terraform Cloud.

Удалённый бэкенд может работать или с одним удаленным пространством имен Terraform Cloud, или с набором однообразно
именованных удалённых рабочих пространств (например, `networking-dev`, `networking-prod` и т.д.). В блоке `workspaces`
конфигурации бэкенда задаётся, какой из режимов используется:
- для использования единственного рабочего пространства Terraform Cloud следует указать в параметре `workspaces.name`
полное имя удалённого рабочего пространства (например `networking-prod`);
- для использования набора удаленных пространств имен следует установить в параметр `workspaces.prefix` тот префикс,
который используется во всех именах рабочих пространств.

Если предыдущее состояние существует, а соответствующие удалённые рабочие пространства отсутствуют или пусты, то
при запуске `terraform init` Терраформ создаст эти рабочие пространства и обновит удалённое состояние. Однако,
если для выполнения удалённых операций рабочему пространству требуются переменные или особая версия Терраформа,
то рекомендуется создавать удаленные пространства до запуска в них удаленных операций.


#### Использование рабочих пространств

Большинство команд Терраформа взаимодействуют только с текущим выбранным рабочим пространством. Это касается команд
по управлению ресурсами (`plan`, `apply` и `destroy`) и по управлению состояниями.

Можно создать несколько рабочих каталогов для поддержки нескольких экземпляров конфигурации с полностью
разделенными состояниями. Но Терраформ устанавливает отдельный кэш плагинов и модулей для каждого рабочего
каталога и поддержка нескольких каталогов ведет к перерасходу пропускной способности сети и дискового пространства.
Кроме того, такой подход требует выполнения дополнительных задач, вроде обновления конфигурации из СКВ для
каждого каталога в отдельности и реинициализации каждого каталога при изменении конфигурации. Рабочие же пространства
тем и удобны, что позволяют создавать различные наборы инфраструктуры из одной и той же рабочей конфигурации
и одного и того же кэша плагинов и модулей.

Типичным случаем использованием нескольких рабочих пространств является создание отдельной параллельной копии
инфраструктуры для тестирования изменений перед модификацией производственной инфраструктуры.

Недефолтные рабочие пространства часто связаны с функциональными ветками СКВ. Дефолтное рабочее пространств может
соответствовать веткам `main` или `trunk`, описывающими требуемое состояние производственной инфраструктуры. Когда
разработчик создаёт функциональную ветку для сохранения в ней некоторой модификации, то он также может создать
соответствующее рабочее пространство и разворачивать его во временной копии основной инфраструктуры. На этой
копии инфраструктуры разработчик может тестировать различные изменения без влияния на производственную инфраструктуру.
Когда изменение объединяется с дефолтным рабочим пространством, то тестовая инфраструктура и временное рабочее
пространство м.б. удалены.

#### Когда не следует использовать рабочие пространства
Т.о. рабочие пространства позволяют быстро переключаться между несколькими экземплярами **одной и той же конфигурации**
в пределах **одного бэкенда**. Но рабочие пространства не призваны решать все проблемы.

При использовании Терраформа для управления большими системами всё же следует создавать отдельные конфигурации,
соответствующие архитектурным границам внутри системы. Это позволяет командам управлять различными
системами по-отдельности. Сами по себе рабочие пространства не являются подходящим инструментом для декомпозиции
систем, потому что каждая из подсистем должна иметь собственную отдельную конфигурацию и бэкенд.

Кроме того, организации зачастую хотят иметь строгое разделение между разными инсталляциями одной и той же
инфраструктуры, обслуживающей различные стадии разработки различными внутренними командами. В этом случае
бэкенд каждой инсталляции часто использует различные учётные данные и контроль доступа. CLI рабочих пространств
в пределах рабочего каталога используют один и тот же бэкенд, поэтому рабочие пространства не являются
подходящим изоляционным механизмом для такого случая.

Альтернативом рабочим пространствам может являться использование модулей.

#### Внутреннее устройство рабочего пространства

Технически рабочие пространства являются эквивалентом переименования файла состояния. Терраформ дополняет удалённое
состояние набором защит и поддержек.
Рабочие пространства часто подразумеваются в качестве ресурсов с разделяемым доступом. Они являются приватными до
тех пор, пока используются как чисто локальное состояние или не будут переданы в СКВ.

Для локального состояния Терраформ сохраняет состояния рабочего пространства в директории с
именем `terraform.tfstate.d` С этой директорией следует работать также, как и с локальным файлом `terraform.state`.
Некоторые команды сохраняют свои файлы в СКВ, всё же рекомендуется вместо этого использовать удалённый бэкенд.

Для удалённого состояния рабочие пространства сохраняются непосредственно в сконфигурированный бэкенд.
Для гарантированного сохранения состояния во всех бэкендах имя рабочего пространства д.б. валидным сегментом URL
без какого-либо преобразования.

Терраформ сохраняет текущее рабочее пространство локально в игнорируемой директории `.terraform`.
Благодаря этому разные члены команды могут одновременно работать в разных рабочих пространствах.

#### Имена рабочих пространств

Для взаимодействия с рабочими пространствами через CLI Терраформ использует сокращенные имена без общего префикса.
Например, если префикс `networking-` то для переключения на рабочее пространство используется
команда `terraform workspace select prod`. Однако, такие удалённые операции Терраформа, как `plan` или `apply`
для Terraform Cloud будут выполняться в рабочем пространстве `networking-prod`.
По этой причине выражение terraform.workspace будет возвращать разный результат в зависимости от того,
настроено удалённое рабочее пространство на выполнение операций локально или удалённо. Например, в удаленном
рабочем пространстве `networking-prod` (префикс `networking-`), выражения дадут следующий результат:
- для локальных операций: `terraform.workspace=prod`;
- для удалённых операций: `terraform.workspace=networking-prod`;


---

> Можно инициализировать бэкенд командой:
> ````bash
> $ terraform init \
> -backend-config="endpoint=storage.yandexcloud.net" \
> -backend-config="bucket=tf-backend" \
> -backend-config="region=ru-central1-a" \
> -backend-config="key=tfstate" \
> -backend-config="access_key=$AWS_ACCESS_KEY_ID" \
> -backend-config="secret_key=$AWS_SECRET_ACCESS_KEY" \
> -backend-config="skip_region_validation=true" \
> -backend-config="skip_credentials_validation=true" \
> -backend-config="workspace_key_prefix=tf-state" \
> -reconfigure
>
> Initializing the backend...
> Do you want to copy existing state to the new backend?
>   Pre-existing state was found while migrating the previous "local" backend to the
>   newly configured "s3" backend. No existing state was found in the newly
>   configured "s3" backend. Do you want to copy this state to the new "s3"
>   backend? Enter "yes" to copy and "no" to start with an empty state.
>
>   Enter a value: yes
> ...
> ````
>
> Для последующей реконфигурации бэкенда чтобы игнорировать сохраненные конфигурации можно выполнить:
> `terraform init -reconfigure`